# Open Source SW

## getopt

#### 1) 용도
* 명령형 플래그와 매개변수를 구문 분석

#### 2) 설명
* 예상되는 플래그와 인수를 지정하는 형식을 사용하여 토큰 리스트를 구문 분석함
* 여기서 플래그는 단일 ASCII 문자이며 뒤에 콜론(:)이 올 경우 하나 이상의 탭 또는 공백으로 분리하거나 분리할 수 없는 인수가 필요함
* 인수에는 복수 바이트를 포함시킬 수 있지만 플래그 문자로는 포함시킬 수 없음
* 모든 토큰을 읽은 후 또는 특수 토큰 -이 발생하는 경우 처리를 완료함
* 처리된 플래그, -과 남아 있는 토큰을 출력
* 토큰이 플래그와 일치하지 않을 경우 메시지를 표준 오류에 기록함

#### 3) 예제
```shell
#!/bin/bash

set -- $(getopt -q abc:d "$@")

while [ -n "$1" ]
do
  case "$1" in
      -a) echo "-a option";;
      -b) echo "-b option";;
      -c) echo "-c option";;
      --) whift
      break;;
      *) echo "$1 not option"
   esac
   shift
done

cnt=1
for arg in "$@"
do
  echo "argument #$cnt: $arg"
  cnt=$[ $cnt + 1 ]
done
```
![getopt](https://user-images.githubusercontent.com/76931115/141967578-5a479767-9d7b-485c-ab0c-30b72ecc6c63.jpg)

#### 4) 파일 위치
> /usr/bin/getopt



## getopts

#### 1) 용도
* 명령행 인수를 처리하고 유요한 옵션을 검사함

#### 2) 설명
* 매개변수 리스트에서 옵션과 옵션 인수를 검색하는 Korn/POSIX 쉘 내장 명령
* 옵션은 + 또는 -로 시작하고 그 뒤에 문자가 오며 +나 -로 시작하지 않는 옵션은 OptionString을 종료함
* 호출될 EO마다 Name의 다음 옵션 값과 쉘 변수 OPTIND에서 처리될 다음 인수의 색인을 배치함
* 쉘이 호출될 때마다 OPTIND는 1로 초기화
* 옵션이 +로 시작하는 경우 +는 Name 값 앞에 추가됨
* OptionString의 문자 뒤에는 콜론(:)이 오면 옵션에 인수가 있는 것으로 간주함
* 옵션에 옵션-인수가 필요한 경우 변수 OPTARG에 배치함

OptionSting에 포함되지 않은 옵션 문자가 발견되거나 찾은 옵션에 필요한 옵션 - 인수가 없는 경우
* OptionString이 콜론(:)으로 시작되지 않는 경우
- Name은 물음표(?) 문자로 설정됨
- OPTARG가 설정되지 않음
- 진단 메시지가 표준 오류에 기록됨
* 명령을 처리하는 중에 생긴 오류는 아니며, 호출 애플리케이션에 인수가 표시되는 중에 발견된 오류라고 간주
* 진단 메시지는 명시된 대로 기록되지만 종료 상태는 0이 됨

* OptionString이 콜론(:)으로 시작되는 경우
- Name은 물음표(?)로 설정되거나 누락된 필수 옵션에 대해서는 콜론(:) 문자로 설정됨
- OPTARG는 발견된 옵션 문자로 설정
- 출력이 표준 오류에 기록되지 않음

* 옵션의 끝에 도달하는 경우 
- getopts 명령은 0보다 큰 리턴 값을 종료
- OPTARG는 첫 번째 비옵션-인수의 색인으로 설정, 첫 번째 --인수는 그 전에 다른 비옵션-인수가 나타나지 않는 경우 옵션-인수로 간주되고 비옵션-인수가 없는 경우에는 값 $#+1로 간주
- Name은 물음표(?) 문자로 설정

#### 3) 매개변수
|항목|설명|
|:---:|---|
|OptionString|getopts 명령이 인식하는 옵션 문자의 문자열을 포함, 문자 뒤에 콜론이 오는 경우 해당 옵션은 인수가 있는 것으로 간주, 인수는 별도의 인수로 제공, 공백을 사용하여 옵션을 인수와 분리할 수 있음, 첫 번째 문자는 옵션 문자를 알 수 없거나 옵션-인수가 누락된 경우 getopts 명령이 작동하는 방식을 판별, 물음표 및 콜론 문자는 애플리케이션에 의해 옵션 문자로 사용되어서는 안됨, 영숫자가 아닌 기타 문자의 사용은 지정되지 않은 결과를 생성|
|이름|getopts 명령에 의해 발견된 옵션 문자로 설정|
|Argument|공백으로 분리된 하나 이상의 문자열, 올바른 옵션인지 getopts 명령이 검사, 생략되는 경우 위치 매개변수가 사용됨, 일반적으로 Argument를 getopts 명령의 일부로 지정하지 않지만 스크립트를 디버깅할 때 지정하는 것은 유용함|

#### 4) 종료 상태
|항목|설명|
|:---:|---|
|0|OptionString에 의해 지정되거나 지정되지 않은 옵션이 발견|
|>0|옵션의 끝에 도달했거나 오류가 발생|

#### 5) 예제
```shell
#!/bin/bash
while getopts "a:b:c" opt
do
  case $opt in
    a) echo "a";;
    b) echo "b";;
    c) echo "c";;
  esac
done
```
![getopts](https://user-images.githubusercontent.com/76931115/141967704-45ed6787-33ff-41a5-ba58-4e6258f6b832.jpg)

## sed

#### 1) 용도
* 스트림 편집기

#### 2) 설명
* 원본을 건드리지 않고 편집하기 때문에 원본에는 영향이 없음(단, -i 옵션을 지정하면 원본 변경 가능)
* p 조건을 추가할 경우 특정 행을 출력
* d 조건을 추가할 경우 특정 행을 삭제
* s 조건은 단어를 치환함
* a, i 조건은 문자열을 추가
* c 조건은 특정 행의 내용을 전부 교체함
* r 조건은 특정 행에 파일의 내용을 추가함
* 편집 스크립트에 따라 지정된 File 매개변수에서 행을 수정하고 표준 출력에 작성
* 수정하려는 행을 선택하고 선택된 행만 변경하기 위한 많은 기능이 포함
* 수정되는 행을 보유하기 위해 두 개의 작업공간 사용
* 선택된 행이 보유되는 곳에는 패턴 공간을 사용, 행이 임시로 저장될 수 있는 곳에는 보유 공간 사용
* 편집스크립트는 별도의 각 행에 개발 부속 명령으로 구성
* 입력 행을 패턴 공간으로 읽어들이고 주소가 해당 행을 선택하는 순서, 모든 sed 부속 명령을 적용하며 표준 출력에 패턴 공간을 기록하여 각 입력 FIle 매개변수를 처리
* 다음, 패턴 공간을 지우고 입력 File 매개변수에 지정되는 각 행에 대해 이 프로세스를 반복
* 일부 sed 부속 명령은 보류 영역을 사용하여 후속 검색을 위해 패턴 공간의 일부 또는 모두를 저장
* 명령에 주소(행 번호 또는 검색 패턴)가 포함될 때, 주소 지정된 행 또는 행만 명령에 의해 영향을 받음
* 그렇지 않으면, 명령이 모든 행에 적용
* 입력의 마지막 행을 주소 지정하는 주소는 10진수 행 번호인 $ 또는 문맥 주소
* 문맥 주소는 ed 명령에 사용되는 것과 유사한 정규식
- 패턴에 대한 분리 문자를 선택할 수 있음
- 물음표(?)는 선택 가능한 분리 문자
- 공간 또는 줄 바꾸기 문자를 제외하고 선택할 수 있음
- 백슬래시(\) 문자는 물음표(?)의 첫 번째 발생에만 필요
- 디폴트 시 백슬래시(\) 문자는 필요하지 않음
- \n 시퀀스는 줄 바꾸기, 문자 종료를 제외하고 패턴 공간에서 줄 바꾸기 문자와 일치
- 마침표(.)는 줄 바꾸기, 문자 종료를 제외하고 문자와 일치
- 행의 중간에 줄 바꾸기 문자와 일치할 수 없는 ed 명령어, sed 명령은 패턴 공간의 줄 바꾸기 문자와 일치할 수 있음
- addressed 명령이라는 특정한 명령을 사용하면 명령이 적용되어야 하는 행의 범위 또는 하나의 행을 지정할 수 있음
- 주소가 없는 명령행은 모든 행을 선택
- 문맥 형식으로 표시된 하나의 주소가 있는 명령행은 그 주소와 일치하는 각 행을 선택
- 쉼표로 구분된 두 개의 주소를 가지는 명령행은 두 번째 주소와 일치하는 다음 행을 통해 첫 번째 주소와 일치하는 첫 번째 행에서 전체 범위를 선택
- 첫 번째 주소를 다시 검색하여 프로세스 반복

#### 3) 플래그
|항목|설명|
|:---:|---|
|-e 스크립트|편집 스크립트로서 스크립트 변수를 사용, 하나의 -e 플래그와 -f 플래그도 사용하고 있지 않으면, -e 플래그는 생략 가능, 다중 사용 가능|
|-f ScriptFile|편집 스크립트의 소스로서 ScriptFile 변수를 사용, ScriptFile 변수는 File 매개변수에 적용되는 준비된 편집 명령 세트|
|-n|표준 출력으로 정상적으로 기록된 모든 정보를 억제|
|-u|버퍼 없음 모드에서 출력을 표시, 플래그가 설정될 때, sed 명령은 출력을 버퍼링하는 대신 즉시 출력을 표시, 디폴트는 버퍼링된 모드|

#### 4) 종료 상태
|항목|설명|
|:---:|---|
|0|성공적 완료|
|>0|오류 발생|

#### 5) 예제
```shell
$ sed -n '1p' employees;
$ sed -n '1, 3p' employees;
```
![sed](https://user-images.githubusercontent.com/76931115/141967754-c5167660-0a51-47e5-abb8-b4a2f20cc468.jpg)

## awk

#### 1)용도
* 파일에서 패턴이 일치하는 행을 찾아서 그러한 행에 지정한 조치를 수행함

#### 2) 설명
* 사용자가 제공하는 명령어 세트를 사용하여 사용자가 제공한 확장 정규식과 파일 세트를 한 번에 한 행씩 비교
* 확장 정규식과 일치하는 모든 행에서 조치를 실행
* 패턴 검색은 grep 명령의 패턴 검색보다 더 일반적, 이 경우 사용자는 입력 텍스트 행에 대해 여러 가지 조치를 실행할 수 있음
* 프로그래밍 언어에는 컴파일이 필요하지 않으며, 사용자는 변수, 숫자 함수, 문자열 함수, 논리적 연산자를 사용할 수 있음
* LANG, LC_ALL, LC_COLLATE, LC_CTYPE, LC_MESSAGES, LC_NUMERIC, NLSPATH, PATH 환경 변수의 영향을 받음

awk 명령에 대한 입력
* 두 종류의 입력, 입력 텍스트 파일과 프로그램 명령어를 사용
입력 텍스트 파일
* 검색과 조치는 입력 텍스트 파일에서 실행
- 명령행에서 File 변수를 지정
- 특수 변수 ARGV 및 ARGC를 수정
- File 변수가 없으면 표준 입력을 제공
프로그램 명령어
* 사용자가 제공하는 명령어는 awk 명령의 조치를 제어
* 이 명령어는 명령행의 ‘Program' 변수에서 가져오거나 ProgramFile 변수와 함께 사용된 -f 플래그로 지정한 파일에서 가져옴
* 여러 프로그램 파일이 지정되면, 파일은 지정된 순서에 따라 병합되고 그 결과로 생성되는 명령어의 순서가 사용됨

awk 명령에 대한 출력
* 입력 텍스트 파일에 있는 데이터로부터 세 가지 종류의 결과를 출력
- 선택된 데이터는 입력 파일을 변경하지 않고 표준 출력으로 인쇄될 수 있음
- 입력 파일 중 선택된 부분을 변경할 수 있음
- 선택된 데이터는 입력 파일 컨텐츠 변경 여부와는 상관없이 변경되고 표준 출력으로 출력될 수 있음

* 내장함수, 산술 함수, 문자열 함수, 일반 함수 사용자 정의 함수 등 포함

#### 3) 플래그
|항목|설명|
|:---:|---|
|-f ProgramFile|지정된 파일로부터 awk 명령에 대한 명령어를 얻음, -f 플래그가 여러 번 지정되면 지정된 순서로 병합된 파일이 명령어 세트로 사용됨|
|-u|버퍼링되지 않은 모드로 출력을 표시, 이 플래그를 사용하면 awk 명령 출력을 버퍼링하지 않음 대신, 즉시 출력을 표시|
|-F Ere|Ere 변수로 지정된 확장 정규식을 필드 구분자로 사용, 디폴트 필드 구분자는 공백|
|-v Assignment|프로그래밍 언어에서 변수에 값을 지정, Assisgnment 매개 변수는 Name = Value 양식, Name 부분은 변수 이름을 지정, 밑줄, 숫자, 영문자의 조합일 수 있음 단, 밑줄 또는 영문자로 시작해야 함, Value 부분도 밑줄, 숫자, 영문자 구성 앞뒤에 “가 있는 경우처럼 처리, Value 부분이 숫자인 경우, 변수에도 숫자 값이 지정|
|Assignment|프로그래밍 언어에서 변수에 값을 지정, 각각 처리되는 시간을 제외하고 -v 플래그를 포함하는 Assignment 변수와 양식 및 기능이 동일, Assignment 매개변수는 명령행에서 이 뒤에 나오는 입력 파일 바로 앞에서 처리, Assisgnment 매개변수가 여러 입력 파일의 첫 번째 파일 바로 앞에 지정되면 BEGIN 섹션 바로 뒤에서 처리, 마지막 파일 이후 Assignment 매개변수가 나타나면 END 섹션 전에 처리, 입력 파일이 지정되지 않은 경우, 지정이 처리되고 표준 입력을 읽음|
|File|처리를 위한 입력을 포함하고 있는 파일 이름을 지정, File 변수가 지정되지 않거나 - 기호가 지정된 경우 표준 입력이 처리|
|'Program'|-f 플래그를 지정하지 않은 경우 Program 변수는 명령행의 첫 번째 항목이어야 함, 이는 ‘’로 묶어야 함|

#### 4) 종료 상태
|항목|설명|
|:---:|---|
|0|성공적 완료|
|>0|오류 발생|

#### 5) 예제
```shell
$ awk '{print $0}' employees
```
![awk](https://user-images.githubusercontent.com/76931115/141967793-e2c5c58c-deda-45c8-8df9-3031cd52cb90.jpg)


###### 출처
employees 파일 출처 : https://jhnyang.tistory.com/287
ibm.com/kr-ko
https://reakwon.tistory.com/164
